\chapter{Experimental Results} % (fold)
\label{cha:experiments}

This chapter presents the experimental work completed to validate the actuator dynamics and motion control framework. It is important to test walking control strategies on physical hardware directly due to the imperfections in a simulation environment. For example, the contact models used to estimate the ground reaction force is only an approximation. There are also other unmodeled effects which can significantly alter the dynamics of the physical system (i.e. friction). The hardware platform used for experimental validation is presented in Section~\ref{sec:physical_hardware}. This includes the mechanical implementation of the bipedal robot design and the control electronics used to control the robot. 

The simulations used to demonstrate the proposed 3D FPE walking control strategy in the previous section accounted for link side dynamics only. Section~\ref{sec:actuator_model} describes the modifications to account for the actuator dynamics. This modification to the simulations enables a single controller designed in Simulink to target either the simulation environment or the physical hardware using the HIL architecture discussed in Section~\ref{sec:hil_architecture}. The experimental validation for a single actuator and the proposed motion control framework are presented in Sections \ref{sec:1dof_validation} and \ref{sec:motion_control_validation}, respectively. 

\section{Physical Hardware} % (fold)
\label{sec:physical_hardware}
The electromechanical design presented in Chapter~\ref{cha:design} was realized to develop the 14 DOF bipedal robot. A completely assembled 7 DOF leg of the biped is shown in Figure~\ref{fig:bipedleg}. The mechanical implementation was derived directly from the revised CAD models. The control electronics were developed by an industry partner, Quanser Inc. This section presents the realization of the physical hardware platform used for experimental validation. 

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.39]{fig/hardware/bipedleg.png} 
  	\caption{The 7 DOF leg built for the bipedal robot based on the electromechanical design in Chapter~\ref{cha:design}.}
	\label{fig:bipedleg}
\end{figure}

\subsection{Mechanical Implementation} % (fold)
\label{sub:mechanical_implementation}

The final mechanical design of the bipedal robot was developed on campus at the University of Waterloo. The on-site engineering machine shop manufactured the mechanical chassis components from the final CAD drawings (shown in Appendix~\ref{app:bipedcad}). The selected DC motors and gearhead combinations were sourced from a motor manufacturer. The drivetrain components (i.e. bearings, shafts, gears) used to relocate the output gearhead shaft from each joint axis were also sourced from a hardware vendor. The author of this thesis completed the mechanical assembly using the CAD model as a reference. The completely assembled joints and links of the bipedal robot leg is shown in more detail in Figure~\ref{fig:bipedcloseup}.

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.38]{fig/hardware/bipedcloseup.png} 
  	\caption{Close up pictures of various joints and linkages in mechanical implementation of the bipedal robot design.}
	\label{fig:bipedcloseup}
\end{figure}

The mechanical chassis was composed primarily out of Aluminum 5052 and created using Computer Numerical-Controlled (CNC) machine tools directly from the CAD files. This enabled repeatable and accurate positioning of mechanical features in the chassis components (i.e. for the separation of holes for gearing components to mesh well). The use of CNC machine tools was also useful since some chassis components (i.e. motor mounts) were used multiple times in the design of each leg. The advantage here was once the machine was setup to produce the first component, the remaining copies could be produced faster using the same setup. 

One of the key challenges in the assembled leg was the use of bevel gears for perpendicular mechanical coupling. It was difficult to position the gear axis with enough accuracy to achieve perfect clearance between mating components. As a result, some of the joints which use this design approach to shift the weight distribution suffer from backlash (or ``joint play''). In the current design, this is particularly evident for the knee joint, where one of the stock gearing components were modified due to fitment issues. 

In addition to developing the bipedal robot, a supporting frame was also designed for fixed and walking experiments (CAD drawings available in Appendix~\ref{app:framecad}). In the fixed configuration, the biped's torso is mounted directly to the frame. This provides sufficient ground clearance for the legs to remain suspended in the air. This removes the $n = 6$ unactuated DOF from the floating base but provides an experimental platform for testing basic control strategies (i.e. controlling swing foot motion). The walking configuration was designed to provide sufficient clearance for the biped to be mobile, while using a tether to provide support in case of a fall. 
% subsubsection mechanical_implementation (end)

\subsection{Control Implementation} % (fold)
\label{sub:control_implementation}

\begin{figure}[!b]
	\centering
    \includegraphics[scale=0.39]{fig/hardware/bipedwired.png} 
  	\caption{Electronics and wiring used to interface control loops running in Simulink to the physical hardware.}
	\label{fig:bipedwired}
\end{figure}

The electronics used for controlling the bipedal robot was developed by an industry partner. Quanser Inc developed custom motor controllers and drivers for the current requirements derived from torque estimates in dynamic simulations. Each joint in the bipedal robot has a (dedicated) local motor controller and driver unit. A control system model developed in Matlab/Simulink using Quanser's QUARC toolbox communicates with the electronics hardware through a serial interface (USB). Quanser's complete system enables hardware-in-the-loop (HIL) experiments with the physical bipedal robot (described further in Section~\ref{sec:hil_architecture}).    

Unfortunately, the electronics hardware developed by Quanser was not ready in time for experimental validation. Since it is a custom solution, further development was required before it could be used to control the complete 14 DOF bipedal robot. Quanser provided the author with control electronics from their existing product offerings in the interim to complete \emph{some} experimental validation on the physical robot. The general idea is that the HIL experiment models developed to target the interim solution could easily be switched to target the custom solution once it is ready. The interim solution is hardware constrained to 7 channels and the current output per channel. A single 7 DOF leg shown in Figure~\ref{fig:bipedwired} was wired to these channels for experimental validation in this chapter. 

% subsubsection electronics_implementation (end)

% section physical_hardware (end)

\section{Actuator Model} % (fold)
\label{sec:actuator_model}
PD control is applied for each joint in order to track the desired trajectory generated by higher levels of control (Section~\ref{sub:control_strategy}). The control signal $u$ produced at each joint $k$ is provided by (where $k = 1 \ldots n$ is the $k$-th joint of the $n$-DOF system) : 

\begin{equation}
	{u_k} = {K_P}({q_{d_k}} - {q_k}) - {K_D}{\dot q_k}
	\label{eq:pdcontrollaw}
\end{equation} 

Where ${q_{d_k}}$ and ${q_k}$ are the desired and actual angles and ${\dot q_k}$ is the velocity of the $k$-th joint. Constants ${K_P}$ and ${K_D}$ are the porportional and derivative gains of the controller, respectively. In the ideal case, the control signal ${u_k}$ would simply be applied torque ${\tau _k}$ to each joint from $\vtau = \left[\tau _1 \ldots \tau _k \right]$ shown on the right hand side of (\ref{eq:eom1}). However, the actuator dynamics of DC motors used in the development of the 14 DOF bipedal robot must be considered. The motors selected in Section~\ref{sub:final_configurations} are controlled by a voltage control signal $v_{m}$. A second order system is used to model the actuator dynamics and relate the applied torque to the motor voltage $v _m$ \cite{Spong2008}: 

\begin{equation}
	{J_m}{\ddot \Theta _m} + \left( {{B_m} + \frac{{{k_b}{k_m}}}{{{r_a}}}} \right)\dot \Theta _m  = {\tau _m} - \frac{{{\tau _l}}}{{{g_r}}}
	\label{eq:actdyn1}
\end{equation}

Where $\Theta _m$ is the rotor angle, $J_m$ is the motor inertia, $B_m$ is the motor damping, $k_b$ is the back emf or voltage constant, $k_m$ is the torque constant, $r_a$ is the armature resistance and $g_r$ is the gear reduction ratio. The motor torque $\tau _m$ is related to the (link side) load torque $\tau _l$ through the gearing ratio $g_r$. Since the output side of the gearhead is coupled directly to the link, the motor angles are related to the joint angles by: 

\begin{equation}
	{\Theta _{m_k}} = {g _{r_k}} {q _k}
	\label{eq:actdyn2} 
\end{equation}

Similarly, the joint torques in $\vtau$ (\ref{eq:eom1}) are related to the actuator load torques by: 

\begin{equation}
	{\tau _{m_k}} = {\frac{\tau _{k}}{g _{r_k}}} 
	\label{eq:actdyn3}
\end{equation}

Furthermore, the motor torque is related to the applied voltage through the following relationship: 

\begin{equation}
	{\tau _{m_k}} = {k_m} {i_a} = \left( {\frac{{{k_m}}}{{{r_a}}}} \right){v _{m_k}}
	\label{eq:actdyn4}
\end{equation}


Where $i_a$ is the current through the armature wiring. Substituting equations (\ref{eq:actdyn2} - \ref{eq:actdyn4}) back into (\ref{eq:actdyn1}) yields the complete relationship between the $k$-th joint angle, link side torque and the applied motor voltage:

\begin{equation}
	g_r^2{J_m}{\ddot q_k} + g_r^2\left( {{B_m} + \frac{{{k_b}{k_m}}}{{{r_a}}}} \right){\dot q_k} = g_r^{}\left( {\frac{{{k_m}}}{{{r_a}}}} \right){v_k} - {\tau _k}
	\label{eq:actdyn5}
\end{equation}

Note that the drivetrain constants specific to the $k$-th joint are used (i.e. ${J _{m_k}}$, ${B _{m_k}}$, $g _{r_k}$, etc.) in this equation (\ref{eq:actdyn5}). 

\subsection{Independent Joint Control} % (fold)
\label{sub:independent_joint_control}

% subsection independent_joint_control (end)

Using independent joint control \cite{Sciavicco2001}, each joint $k$ of the system is decoupled from the rest of the system and controlled individually. The control signal for each joint is computed directly from its own reference trajectory, position and velocity. This approach does not account for the coupled dynamics of the overall system described by (\ref{eq:eom1}). The link side torques in (\ref{eq:actdyn5}) are treated as a disturbance to the second order system and the motor inertia and damping are modified as follows: 

\begin{equation}
	\begin{array}{l}
		{J_{eff}} = g_r^2{J_m} + {a_{kk}}\\
		{B_{eff}} = g_r^2({B_m} + {k_b}{k_m}/{r_a})
	\end{array}
	\label{eq:actdyn6}
\end{equation}

Where ${J_{eff}}$ and ${B_{eff}}$ are the effective motor inertia and damping \emph{seen} by the joint. The ${a_{kk}}$ in (\ref{eq:actdyn6}) compensates for the inertia of link $k$ by adding the $k$-th diagonal term from the inertia matrix $A(\vec{q})$ in (\ref{eq:eom1}). Substituting back into (\ref{eq:actdyn5}) yields: 

\begin{equation}
	{J_{eff}}{\ddot q_k} + {B_{eff}}{\dot q_k} = g_r^{}\left( {\frac{{{k_m}}}{{{r_a}}}} \right){v_k} - {d_k}
	\label{eq:actdyn7}
\end{equation}

Where ${d_k} = \tau _k$ is the link side torque treated as a disturbance to the system. Taking the control input $u _k$ (\ref{eq:pdcontrollaw}) to be the voltage signal $v _m$ in (\ref{eq:actdyn7}) yields a closed loop controller for independent joint control with actuator dynamics (implemented in Figure~\ref{fig:pdmotorcontroller}).

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.5]{fig/experiments/pdmotorcontroller.eps} 
  	\caption{PD controller model for independent joint control with actuator dynamics.}
	\label{fig:pdmotorcontroller}
\end{figure}

To improve the estimate of the motor side inertia, $a_{kk}$ is required in (\ref{eq:actdyn6}). The dynamic simulation package used in Section~\ref{sec:simulations_and_results} is based on the Matlab/Simulink environment and uses the SimMechanics toolbox which does not allow the mass matrix $A(\vec{q})$ to be isolated. Algorithm~\ref{alg:massdiag} was used to compute the mass matrix and extract the diagonal terms at each time step. \\

\begin{algorithm}[H]
 \SetAlgoLined
 Initialization\;
 Set $\vec{q} = \vec{q}_0$, $\vec{\dot q} = \vec{\dot q}_0$, $\vec{\ddot q} = \vec{0}$\;
 \While{1}{
  Compute $\hat{\vtau}$ using RNE with $\vec{\ddot q} = \vec{0}$\;
  \For{$i = 1$ to $n$}{
  Set $\tilde{\vec{g}} = \vec{0}$, $\mathbf{\tilde{\dot{q}}} = \vec{0}$, $\mathbf{\tilde{\ddot{q_i}}} = 1$, $\mathbf{\tilde{\ddot{q_j}}} = 0$ $[j \ne i]$\;
  Compute $\tilde{\vtau}$ using RNE\;
  Form $i$-th column: $A(\vec{q})_{i} = \tilde{\vtau} - \hat{\vtau}$
  }
  Combine columns to form $A(\vec{q})$\;
  Select diagonal elements of $A(\vec{q})$\;
 }
 \caption{Computing mass matrix diagonal terms with RNE algorithm}
 \label{alg:massdiag}
\end{algorithm}

% section actuator_model (end)

\section{HIL Architecture} % (fold)
\label{sec:hil_architecture}
The architecture used to control the physical 14 DOF bipedal robot is presented in this section. In general, controlling DC motors requires a controller (to host the control algorithm) and a driver (typically serves as a power amplifier). The controller outputs a low voltage control signal which is amplified by the driver and applied to the terminals of the motor. Encoders are used to sense the rotor position information and passed back to the controller for closed loop  control. 

The physical bipedal robot in Section~\ref{sub:mechanical_implementation} is treated as the plant. Using Quanser's QUARC toolbox, control algorithms developed in the Simulink environment can be compiled for a variety of target platforms ranging from embedded microcontrollers to standard PC. This allows the use of a shared codebase for simulation and for the physical hardware. The control algorithms used for the biped are compiled and executed on a PC which communicates with the physical hardware through a data acquisition (DAQ) board. A separate and dedicated voltage amplifier is used to drive the DC motors from a low voltage analog control signal (labeled ``amplifier command'' on Figure~\ref{fig:hilarch}) from the controller via the DAQ. As an interim solution, Quanser provided the author with a Q8-USB (DAQ board) and a VoltPAQ (voltage amplifier) shown in Figure~\ref{fig:bipedwired}.

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.65]{fig/experiments/hilarchitecture.eps} 
  	\caption{Hardware architecture used to control the physical bipedal robot leg.}
	\label{fig:hilarch}
\end{figure}

The actuator subassemblies selected in Section~\ref{sub:final_configurations} were preassembled with incremental optical encoders mounted to the motor side. These encoders output digital signals on two channels for an indication and control of the motor shaft position and direction.  These digital signals are passed back to the controller running on the PC via the DAQ. Using quadrature decoding, the motor angle $\Theta _m$ and velocity $\dot{\Theta}_m$ can be retrieved from the encoder output in degrees: 

\begin{equation}
	{\Theta _m} = \frac{{360}}{{n \cdot l}} \cdot Encoder_{output}
\end{equation}

Where $n = 4$ for quadrature (4X) decoding and $l$ is the lines per revolution specified from the encoder manufacturer. Using the relationship between the motor variables and the joint variables in (\ref{eq:actdyn2}), an estimate of the $k$-th link side angle (at the output of the gearhead) can be obtained: 

\begin{equation}
	{q_k} = \frac{{360}}{{4 \cdot l \cdot {g_{{r_k}}}}} \cdot Encode{r_k}
	\label{eq:quadrature}
\end{equation}

This is only an estimate of the joint angle since there are drivetrain losses (i.e. in the gearhead) which are ignored by an encoder mounted to the motor side. 

\subsection{Parallel Models} % (fold)
\label{sub:parallel_models}

The ability to develop a single controller and target either a simulation environment or the physical hardware is extremely useful. Using the Quanser's QUARC toolbox, a Q8-USB (DAQ) board and a VoltPAQ (voltage amplifier), the control algorithms were redeveloped as parallel models capable of switching target platforms (shown in Figure~\ref{fig:parallelmodels}).

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.6]{fig/experiments/parallelmodels.eps} 
  	\caption{Parallel models designed to target either simulations or physical hardware with the same controller.}
	\label{fig:parallelmodels}
\end{figure}

In the physical environment mode shown in Figure~\ref{fig:hilmodel}, the hardware target subsystem is initialized to interface with the Q8-USB DAQ board. The control algorithm running on the PC communicates with the physical hardware using ``HIL Read'' and ``HIL Write'' blocks which communicate with the DAQ over USB. The PD controller output is an analog signal corresponding to the desired voltage at the motor terminals (amplifier command). The DAQ also reads the raw digital signals from the motor side encoders. The VoltPAQ voltage amplifier also provides the ability to read the current in the armature circuit ($i_a$) of the DC motor. This value is passed back to the controller through the DAQ using an analog channel. Due to the noise in the current sensor, a low pass filter is used to produce a cleaner signal. The quadrature decoding formula (\ref{eq:quadrature}) is used to obtain the joint angle for the closed loop feedback. The link side angle information is also used to determine whether a joint is out of its limits. The controller detects and sends a ``shut down'' command to the amplifier channel if it is. 

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.5]{fig/experiments/hilmodel.eps} 
  	\caption{HIL subsystem from Figure~\ref{fig:parallelmodels} used to target physical hardware with voltage control signal.}
	\label{fig:hilmodel}
\end{figure}

In the simulated environment mode, the controllers were reformulated to use the voltage signal as the control input. The simulation target subsystem shown in Figure~\ref{fig:simmodel} models the actuator dynamics and treats the link side torques as a disturbance input. The VoltPAQ amplifier gain ($3$ V/V) is applied to the voltage control signal to model the effective voltage at the motor terminals. The actuator dynamics are simulated with the motor ($R$, $K_m$, $K_b$, $J_m$ and $B_m$) and gearhead ($g_r$) parameters. The link side variables are obtained by applying the gear ratio to the motor velocity $\dot{\Theta}_m$ to obtain $\dot{q}$. The joint position and accelerations are computed by taking the integral and derivative of $\dot{q}$, respectively. The joint angle, velocity and accelerations ($q$, $\dot{q}$, $\dot{\dot{q}}$) are used with inverse dynamics to compute the effective link side torques, which is fed back as a disturbance input to the simulated motor model. 

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.5]{fig/experiments/simmodel.eps} 
  	\caption{Subsystem from Figure~\ref{fig:parallelmodels} used to target the simulated environment with voltage control signal.}
	\label{fig:simmodel}
\end{figure}


% subsection parallel_models (end)

% section hil_architecture (end)

\section{Single DOF Validation} % (fold)
\label{sec:1dof_validation}
This section describes the experiments validating the simulation models for single DOF controllers using the HIL environment. Parallel models developed in Section~\ref{sub:parallel_models} were used to compare the results from simulation to the physical hardware. 

\subsection{Joint Tracking} % (fold)
\label{sub:joint_tracking}
Local PD controllers are used to track the joint level trajectories. The parallel model shown in Figure~\ref{fig:parallelmodels} was developed to tune the proportional ($K_P$) and derivative ($K_D$) gains for individual joints on the bipedal robot. First, the gains were tuned in the simulation environment to achieve the desired tracking performance. The shared controller architecture was then switched to target the physical hardware to validate the tracking results. 

The experimental results presented in this section compare the tracking performance of three joints in simulation and in hardware. Each joint tracks a sinusoidal reference trajectory at $0.5 Hz$. The amplitude and bias of each reference trajectory is selected to maintain the motion within the joint limits. Figures~\ref{fig:hipyawtracking}, \ref{fig:hippitchtracking} and \ref{fig:kneepitchtracking} compare the tracking performance for the hip yaw, hip pitch and knee pitch joints, respectively. 

\begin{figure}[!h]
	\begin{center}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hipyawtrackingsim.eps}}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hipyawtrackinghil.eps}}
	\end{center}
  	\caption{Hip yaw joint tracking results for simulation and hardware.}
	\label{fig:hipyawtracking}
\end{figure} 

% \begin{figure}[!h]
% 	\begin{center}
% 	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hipyawvoltages.eps}}
% 	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hipyawcurrents.eps}}
% 	\end{center}
%   	\caption{Hip yaw joint voltage and current in simulation and hardware.}
% 	\label{fig:hipyawelectrical}
% \end{figure} 

\begin{figure}[!h]
	\begin{center}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hippitchtrackingsim.eps}}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hippitchtrackinghil.eps}}
	\end{center}
  	\caption{Hip pitch joint tracking results for simulation and hardware.}
	\label{fig:hippitchtracking}
\end{figure} 

% \begin{figure}[!h]
% 	\begin{center}
% 	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hippitchvoltages.eps}}
% 	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hippitchcurrents.eps}}
% 	\end{center}
%   	\caption{Hip pitch joint voltage and current in simulation and hardware.}
% 	\label{fig:hippitchelectrical}
% \end{figure} 

\begin{figure}[!h]
	\begin{center}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/kneepitchtrackingsim.eps}}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/kneepitchtrackinghil.eps}}
	\end{center}
  	\caption{Knee pitch joint tracking results for simulation and hardware.}
	\label{fig:kneepitchtracking}
\end{figure} 

% \begin{figure}[!h]
% 	\begin{center}
% 	\subfigure{\includegraphics[scale=0.45]{fig/experiments/kneepitchvoltages.eps}}
% 	\subfigure{\includegraphics[scale=0.45]{fig/experiments/kneepitchcurrents.eps}}
% 	\end{center}
%   	\caption{Knee pitch joint voltage and current in simulation and hardware.}
% 	\label{fig:kneepitchelectrical}
% \end{figure} 
 
% subsection joint_tracking (end)

With the tuned PD gains, the tracking performance on the physical hardware is nearly identical to the simulation environment. Hip yaw joint tracking (Figure~\ref{fig:hipyawtracking}) show that there is a very small but negligible lag on the physical hardware when compared to the simulated system. Hip pitch joint tracking (Figure~\ref{fig:hippitchtracking}) show perfect tracking for the simulated system while there are small disturbances near the peaks of the sinusoidal wave on the physical hardware. This discrepancy is due to the backlash problem discussed briefly in Section~\ref{sub:mechanical_implementation}. The simulated system demonstrates perfect tracking since backlash is not modeled. However, the PD controller gains are sufficiently high for the physical system to overcome the disturbances due to backlash and achieve near perfect tracking. 

% When the hip joint motion changes direction (i.e. at the peaks of the wave) on the physical system, the backlash in the knee   

% section 1dof_results (end)

\section{Motion Control Validation} % (fold)
\label{sec:motion_control_validation}
This section describes the experiments validating the motion control framework in Section~\ref{sub:control_strategy} using the HIL environment. The parallel model concept was extended to develop higher level task space controllers to generate the joint level trajectories for simulation and hardware. The interim control electronics provided by Quanser Inc is limited to controlling 7 DOF simultaneously. Therefore, only a single 7 DOF bipedal robot leg wired to the control electronics was used for the experiments in this section. The biped's torso was rigidly attached to the supporting frame in the fixed configuration, removing the 6 unactuated DOF. The Jacobian matrix used to map the task space and joint space velocities in (\ref{eq:jmap}) is reduced to: 

\begin{eqnarray}
	\J{}{} &=& \begin{bmatrix} \partial \qact \\ \end{bmatrix}_{m \times n} \\
	\dqref &=& \J{}{\#} \dxref \label{eq:calcqref}
\end{eqnarray}

Where $n \leq 7$ is the actuated and controllable DOF supported by the control electronics. The joint level commands are generated from the task space trajectories ($\dxref$) using (\ref{eq:calcqref}). Alternatively, the prioritized task space control scheme in Section~\ref{sub:control_strategy} can be used to simultaneously satisfy high priority constraints. The mapping provided by (\ref{eq:priori}) is simplified by removing the actuator selection matrix $\mathbf{S}$, since there are no unactuated DOF. 

The fixed configuration of the supporting frame causes the 7 DOF leg to naturally hang straight at the start of each experiment (i.e. $\q = \mathbf{0_{7 \times 1}}$). This represents a singular configuration of the leg. In Section~\ref{sec:1dof_validation}, the joint level commands were provided directly to the local PD controller. Computing the joint level commands with (\ref{eq:calcqref}) requires inverting the Jacobian matrix, which is problematic for singular configurations. To address this issue, each experiment starts by directly controlling the joint level trajectories for $t_{init} = 5$ seconds to manually move the leg into a non-singular configuration. 

\subsection{Planar Motion Control} % (fold)
\label{sub:planar_motion_control}
Some motions during the bipedal gait cycle can be simplified to a planar motion control problem. Common motions during the swing phase include bending of the knee joint and tracking an arc-like trajectory for the swing foot position. For these cases, the 3 pitch joints in the 7 DOF leg are primarily used to carry out the desired motion. A simplified version of the motion control framework (\ref{eq:calcqref}) can be used to control the swing foot position in the biped's sagittal plane.

\begin{equation}
	\dqref = \J{}{\#} \dxswing
\end{equation}

\subsubsection{Knee Bending Motion} % (fold)
\label{ssub:knee_bending_motion}

\begin{figure}[!b]
	\centering
    \includegraphics[scale=0.22]{fig/experiments/kneebendframes.png} 
  	\caption{Captured frames during knee bending experiment in simulation and physical hardware.}
	\label{fig:kneebendframes}
\end{figure}

A knee bending motion is achieved by holding the swing foot position and adjusting the height only. The frame captures shown in Figure~\ref{fig:kneebendframes} demonstrate this experiment in simulation and on the physical hardware. The first frame represents a slightly angled configuration of the leg joints after $t_{init} = 5$ seconds. The leg is not completely straightened to avoid the singular configuration. 

\begin{figure}[!t]
	\begin{center}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/simkneebendp.eps}}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hilkneebendp.eps}}
	\end{center}
  	\caption{Task space trajectory tracking for bending the knee and raising the leg in simulation and hardware.}
	\label{fig:kneebendp}
\end{figure} 

\cleardoublepage
% subsubsection knee_bending_motion (end)

\subsubsection{Swing Foot Motion} % (fold)
\label{ssub:swing_foot_motion}

\begin{figure}[!h]
	\centering
    \includegraphics[scale=0.145]{fig/experiments/swingmotionframes.png} 
  	\caption{Captured frames during swing foot motion experiment in simulation and physical hardware.}
	\label{fig:swingmotionframes}
\end{figure}

\begin{figure}[!h]
	\begin{center}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/simswingfootp.eps}}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hilswingfootp.eps}}
	\end{center}
  	\caption{Task space trajectory tracking for swing foot motion in simulation and hardware.}
	\label{fig:swingfootp}
\end{figure} 

\begin{figure}[!h]
	\begin{center}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/simswingfootq.eps}}
	\subfigure{\includegraphics[scale=0.45]{fig/experiments/hilswingfootq.eps}}
	\end{center}
  	\caption{Joint space tracking of generated trajectories from higher level control during swing foot motion.}
	\label{fig:swingfootq}
\end{figure} 
\cleardoublepage
% subsubsection swing_foot_motion (end)





% subsection planar_motion_control (end)

\subsection{Whole Body Motion Control} % (fold)
\label{sub:whole_body_motion_control}
\Incomplete
% subsection whole_body_motion_control (end)

% section motion_control_results (end)

\section{Summary} % (fold)
\label{sec:experiments_summary}
Validating control algorithms on physical hardware is important due to modeling imperfections in the simulation environment. The physical 14 DOF bipedal robot developed in earlier chapters was used for experimental validation through HIL testing. 

For the physical hardware, DC motors are controlled by a voltage signal $v_m$. A second order system was used to model the actuator dynamics and reformulate the existing controllers which controlled the link side torques $\tau _k$. Independent joint control decouples each joint for individual control. Since this approach does not account for the coupled dynamics of the overall system, the link side torques are treated as a disturbance to the actuator dynamics model. The effective motor inertia is reformulated to include the link inertia seen by the joint. A generic RNE-based algorithm was used to extract the mass matrix of the system at every time step to compute the effective motor inertia.

The HIL architecture was developed using Quanser's QUARC toolbox, DAQ board and a voltage amplifier. The controller code developed in Simulink was targetted to execute on the PC. The DAQ board allowed the PC-based controller to communicate with the physical hardware through analog and digital I/O. Quadrature decoding was on the encoder output to obtain the link side joint angles on physical hardware for closed loop feedback control. Parallel simulation models were developed for experimental validation to target the physical hardware or the simulated actuator dynamics. 

The single DOF simulations were demonstrated on physical hardware. The simulated environment was used to tune the PD gains for the physical hardware. It was shown that tracking performance of the PD controller was identical in both environments.  

\Incomplete
% section discussion (end)

% chapter experiments (end)